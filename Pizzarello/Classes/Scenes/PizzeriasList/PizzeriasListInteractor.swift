//
//  PizzeriasListInteractor.swift
//  Pizzarello
//
//  Created by Oleksandr Nechet on 23.07.17.
//  Copyright (c) 2017 Oleksandr Nechet. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import CoreLocation

protocol PizzeriasListBusinessLogic
{
    func fetchPizzeriasOnLoad()
    func requestNextChunkPizzerias()
}

protocol PizzeriasListDataStore
{
    var pizzerias: [Pizzeria] { get }
}

class PizzeriasListInteractor: PizzeriasListBusinessLogic, PizzeriasListDataStore
{
    var presenter: PizzeriasListPresentationLogic?
    var pizzerias: [Pizzeria] = [] {
        didSet {
            pizzeriasListDidUpdated()
        }
    }
    private var store = PizzeriasCoreDataStore()
    private var networkProvider = PizzeriasNetworkProvider()
    private var requestNextChunkPizzeriasInProcess = false
    private var allPizzeriasDidReceived = false {
        didSet { if allPizzeriasDidReceived { presenter?.allPizzeriasDidReceived() } }
    }
    private var location: CLLocationCoordinate2D?
    private let locationDefault = CLLocationCoordinate2D(latitude: 40.89498884760200,
                                                         longitude: -73.9933415680849)
    
    init() {
        location = LocationManager.shared.location
        LocationManager.shared.locationDidUpdated = { location in
            self.location = location
        }
        
        store.fetchedPizeriasDidChanged = { pizzerias in
            self.pizzerias = pizzerias
        }
    }
    
    // MARK: - PizzeriasListBusinessLogic
    
    func requestNextChunkPizzerias()
    {
        guard !allPizzeriasDidReceived
            && !requestNextChunkPizzeriasInProcess else
        { return }
        requestNextChunkPizzeriasInProcess = true
        
        networkProvider.fetchChunkPizzerias(location: getLocation(),
                                            withOffset: pizzerias.count) { result in
            self.requestNextChunkPizzeriasInProcess = false
            
            switch result {
            case .failure(errorMessage: let errorMessage):
                let response = PizzeriasList.FetchPizzerias.Response(result: PizzeriasResponse.failure(errorMessage: errorMessage))
                self.presenter?.presentFetchedPizzerias(response: response)
                
            case .success(result: let pizzerias):
                if pizzerias.isEmpty {
                    self.allPizzeriasDidReceived = true
                }
                else {
                    self.store.createPizzerias(pizzeriasToCreate: pizzerias,
                                               completionHandler: { _ in })
                }
            }
        }
    }
    
    func fetchPizzeriasOnLoad()
    {
        store.fetchPizzeriasWithChangesObserving { result in
            switch result {
            case .success(result: let pizzerias):
                self.pizzerias = pizzerias
                
            case .failure(error: let storeError):
                let response = PizzeriasList.FetchPizzerias.Response(result: PizzeriasResponse.failure(errorMessage: storeError.localizedDescription))
                self.presenter?.presentFetchedPizzerias(response: response)
            }
            
            self.requestFirstChunkPizzeriasIfNeeded()
        }
    }
    
    //MARK: - Helpers
    
    private func pizzeriasListDidUpdated()
    {
        let response = PizzeriasList.FetchPizzerias.Response(result: PizzeriasResponse.success(result: pizzerias))
        self.presenter?.presentFetchedPizzerias(response: response)
    }
    
    private func requestFirstChunkPizzeriasIfNeeded()
    {
        if pizzerias.isEmpty {
            requestNextChunkPizzerias()
        }
    }
    
    ///Provides current user location if available, otherwise will provide default value
    private func getLocation() -> CLLocationCoordinate2D
    {
        var loc: CLLocationCoordinate2D
        
        if location != nil {
            loc = location!
        }
        else {
            loc = locationDefault
            presenter?.displayErrorMessage(errorMessage: Constants.Strings.locationUndefined)
        }
        
        return loc
    }
}
